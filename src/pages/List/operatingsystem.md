
6.中断和异常

中断：操作系统介入管理资源（切换进程，分配I/O设备等），需要使用特权指令，CPU会从用户态转为核心态，使操作系统获得控制权，**中断是切换核心态的唯一途径**。核心态到用户态需要执行特权执行，修改程序状态字PSW。



7.**系统调用**

概念：操作系统为上层提供接口，主要包括命令接口和程序接口，程序接口由一组系统调用组成。系统调用可以理解为可供应用调用的特殊函数，向系统发出请求获得操作系统的管理服务，可以保证系统的稳定性安全性。凡是与资源有关或直接影响其他进程的操作，一定需要操作系统介入，即一定需要系统调用实现。

系统调用和常规库函数的区别：



常规库函数是不涉及系统调用的，但是有的库函数内部被封装好了一些系统调用，用户调用时更方便。

系统调用内部过程：

用户程序传递系统调用参数-->**执行陷入指令（用户态，之后引发内中断）**-->执行系统调用相关服务程序，处理系统调用（核心态）-->返回用户程序

注意：**陷入指令是唯一一个只能在用户态执行，不能在核心态执行的指令**。

二. 进程与线程

1.进程

程序段+数据段+PCB(进程控制块Process Control Block)组成进程实体（进程映像），简称为进程。PCB是进程存在的唯一标志。

严格来说进程是进程实体的执行过程，系统进行资源分配和调度的一个独立的基本单位，有动态性，并发性，独立性，异步性，结构性。

2.进程的组成


3.进程的状态和转换

三种基本状态：运行态，就绪态（其他资源准备完毕，等待CPU），阻塞态（准备其他资源，都分配到位才可能得到CPU的服务，提高利用率）

另外两种：创建态，终止态


4.进程控制

简化理解：就是如何具体实现进程状态的转换

用**原语实现进程控制，原语执行期间不允许中断**，采用关中断指令和开中断指令实现不允许中断。

5.进程通信（进程之间的信息交换）

共享存储：两个进程对共享空间进行互斥的访问。分为基于数据结构的低级共享，基于共享存储区的高级共享。

消息传递：以格式化的消息为单位，通过收发消息的原语进行数据交换。

管道通信：管道是一个大小固定的缓冲区，采用半双工通信，某一时间段只能单向传输。数据以字符流形式写入管道，写满后才能读，然后write()系统调用被阻塞，系统调用read()。读空了read的系统调用被阻塞，才允许写。数据一旦被读出就会从管道抛弃，意味着读进程最多只有一个。

6.线程和多线程模型

什么是线程，为什么要引入线程？    ----有的进程可能需要宏观上同时做很多事情，但是**传统进程里的程序只能被串行执行，没办法实现并发，因此引入线程，把进程里的代码分为不同线程，增加并发度**。线程成为了程序执行流最小单位，是一个最基本的CPU执行单元。

引入线程后有什么变化？  ----引入线程后，**进程仍是资源分配的基本单位，但是线程是处理机调度的最小单位**；各线程之间也能并发，传统进程机制中只能进程间并发；进程间并发需要切换进程的运行环境，系统开销大，线程间如果在同一进程内切换线程，不需要切换进程运行环境，带来的系统开销小。

线程的实现方式        ---用户级线程ULT，通过线程库实现，线程管理由应用程序负责，在用户态下可以完成线程切换，对操作系统来说透明，对用户可见；内核级线程KLT，线程管理由操作系统内核负责，在核心态下才可以完成线程切换，重点：：**内核级线程是处理机分配的单位**。

；组合两种线程方式。


多线程模型： 多对一--多个用户级线程映射到一个内核级线程，用户级线程的切换在用户态就可以完成，但是并发度底，容易阻塞。

​                        多对多--集二者之所长，更合理

​                        一对一--并发能力强，但是一个进程可能占用多个内核级线程，线程切换开销大

7.处理机调度

基本概念：根据某种算法解决各个进程使用处理机的顺序问题，从就绪队列中选择一个进程将处理机分配给它。

三个层次




为减轻系统负担，暂时不执行的进程会被调到外存从而变为 挂起态

8.进程调度的时机，切换过程，方式

什么时候需要 ----当进程主动放弃处理机（进程正常终止，异常，进程发出I/O请求后主动请求阻塞）或者被动放弃处理机(时间片用完，有更紧急的事如I/O中断要处理，有更高优先级的进程进入就绪队列)

什么时候不能调度切换 ---处理中断的过程，操作系统内核程序临界区（普通资源临界区可以进行进程调度和切换），原子操作过程

方式： 非抢占方式和抢占方式（可以优先处理更紧急的进程）

进程切换有代价，需要完成一些数据的保存和恢复，不是切换的越频繁越好。

9.评价调度算法的指标（计算）

**CPU利用率**：忙碌的时间占总时间的比率，通常考察多道程序并发，利用甘特图辅助计算

**系统吞吐量**：单位时间完成作业的数量。总作业数量/总时间

**周转时间**：完成时间-到达时间    作业提交/到达系统 到作业完成的时间间隔。包括：外存后备队列等待高级调度的时间+进程在就绪队列等待进程调度(低级调度)的时间+进程在CPU上执行的时间+进程等待I/O操作完成的时间。

​                     **平均周转时间**： 各作业周转时间之和/作业数       操作系统更关心系统整体表现即平均值

​                      **带权周转时间**：作业周转时间/作业实际运行的时间      **代表着用户满意度**，意思是作业的周转时间是实际CPU运行处理的时间的多少倍，用户体验来说越小越好

​                      平均带权周转时间

等待时间：进程处于等待处理机状态时间之和，指进程建立后等待被处理机服务的时间之和，不包括等待I/O完成期间的时间。等待时间=周转时间-运行时间-I/O操作时间。

对于作业来说，等待时间还要额外加上作业在外存后备队列中等待被调入就绪队列的时间。

响应时间：用户提交请求到首次产生响应所用的时间




t2=1+15+24 =40 , 上来切换给P2处理机

 t3 =18+1+24+1+36=80  , P3等待的时间+切换给P2处理机+切换给P3

t1=30+1+24+1+36+1+12=105, 

平均=225/3 = 75

10.FCFS, SJF, HRRN调度算法

tips：调度算法学习思路： 算法思想，算法规则，作用对象是作业调度or进程调度？，抢占式or非抢占式？优缺点，是否会导致进程或者作业长期得不到服务（饥饿）

10.1 先来先服务 FCFS 

公平，先到先服务，作业先到达后备队列就先调度，进程先到达就绪队列就先调度，非抢占式。

缺点是对短作业不利，带权周转时间很长，对长作业有利。不会导致饥饿

10.2 短作业优先 SJF short Job First  短进程优先 SPF

追求最少的平均等待时间，平均周转时间，平均带权周转时间。

规则就是选择当前已到达且服务时间最短的作业/进程先服务。

未特别说明默认是非抢占式的，有抢占式的版本--最短剩余时间优先算法SRTN


缺点：对短作业有利，对长作业不利。可能产生饥饿现象，可能使长作业长时间得不到服务

10.3 HRRN 高响应比优先

综合考虑等待时间和要求服务的时间，弥补FCFS(等待时间短优先),SJF(要求服务时间短优先)的缺点。

规则每次调度时先计算各个作业的响应比，最高的先服务。  响应比= 等待时间+要求服务时间 / 要求服务时间

是非抢占式的，只有当作业/进程主动放弃处理机才会调度。

优点：均衡了FCFS,SJF的优点，弥补了缺点

11.交互式(分时系统,实时系统)调度算法

11.1 时间片轮转调度算法 RR

公平的轮流给进程执行时间片，时间到了就剥夺处理机，只用于进程调度，作业放入就绪队列才能用。是抢占式的。

时间片太大会增大响应时间，太小也会消费资源。

11.2 优先级调度算法

根据优先级，可以用于进程/作业/IO调度， 抢占式非抢占式都有，抢占式需要在就绪队列变化时检查是否会发生抢占。会发生饥饿

11.3 多级反馈队列调度算法

是对其他算法的折中权衡



12. 进程同步，进程互斥

为什么要进程同步：进程具有异步性，并发的进程以各自独立，不可预知的速度推进，有**时候需要对两个进程有先后顺序的要求，进程同步就是为解决这种异步问题**的。

什么是进程互斥：    由于共享有两种   互斥共享(某些资源可以被多个进程使用但一个时间段内只允许一个进程访问)和同时共享方式(允许一个时间段内多个进程宏观上同时访问)，互斥访问的资源（例如摄像头，打印机，许多变量数据等）属于临界资源，对这种临界资源的访问必须互斥的进行，即一个进程访问临界资源时另一个想访问的进程必须等待。

​          进程互斥逻辑上分为  进入区entry，临界区critical，退出区exit，剩余区remain。  **进入区相当于一个🔒，退出区就相当解锁，临界区是访问临界资源的代码段**。剩余区做其他处理。

​         **进程互斥需要遵循的原则：  1.空闲让进，临界区空闲则允许请求的进程进入 2.当已有进程进入临界区，其他想进入的必须等待。 3.让全等待，当进程不能进入临界区时，要释放处理机，防止进程忙等待 4. 保证等待的进程能在有限时间进入临界区。**

13. 进程互斥的软件实现方法：

    1. 单标志法：每个进入临界区的权限只能被另一个进程赋予，同一时刻最多允许一个进程访问临界区

    ​       算法缺陷：如果P0进程一直不进去临界区，那么临界区是空闲的，但是turn值没有变，其他进程无法进入临界区，违背了空闲让进的原则

​          2.双标志先检查法：用一个数组flag[i] 标记各进程是否想进入临界区。 进程进入临界区前先检查别的进程是否想进入临界区  (P1想进入，那检查P0，while(flag[0])判断，flag[0]为true则满足while条件，说明P0进程想进入，那P1进程就一直再while循环体中等待P0执行完，flag[0]变为false)，如果都没有想进入的就把自己的flag设为true。

​           算法缺陷：先检查，后上锁。两程序并发执行的顺序是不可预知的，当P0P1都询问别的进程是否想进入临界区时，都没有想进入的，于是都各自进入临界区，改变了自己flag值(相当于上锁)，违背了一个进程进入临界区其他必须等待的原则。

​         3.双标志后检查法： 对双标志先检查的改变，把改变flag值(上锁)放在检查别的进程前面，可以 防止两进程都进入临界区。

​         算法缺陷：治标不治本，如果两进程都不询问直接改变自己的flag，可能会出现都改变了flag值，双方都无法进入临界区，产生了临界区空闲，但是两进程都无法进入且两进程一直等待，产生饥饿(类似死锁)










五. I/O管理



